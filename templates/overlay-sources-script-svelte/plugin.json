{"id":"script-id","label":"Your Script","version":0,"sources":[{"label":"Example","subLabel":"An example source","tag":"example-source","inputs":[{"id":"meal","type":"text","label":"Favourite meal","defaultValue":"breakfast","target":"props.meal"}]}],"script":"(() => {\n  // node_modules/svelte/src/runtime/internal/utils.js\n  function noop() {\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return /* @__PURE__ */ Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === \"function\";\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && typeof a === \"object\" || typeof a === \"function\";\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n\n  // node_modules/svelte/src/runtime/internal/globals.js\n  var globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : (\n    // @ts-ignore Node typings have this\n    global\n  );\n\n  // node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js\n  var ResizeObserverSingleton = class _ResizeObserverSingleton {\n    /**\n     * @private\n     * @readonly\n     * @type {WeakMap<Element, import('./private.js').Listener>}\n     */\n    _listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n    /**\n     * @private\n     * @type {ResizeObserver}\n     */\n    _observer = void 0;\n    /** @type {ResizeObserverOptions} */\n    options;\n    /** @param {ResizeObserverOptions} options */\n    constructor(options) {\n      this.options = options;\n    }\n    /**\n     * @param {Element} element\n     * @param {import('./private.js').Listener} listener\n     * @returns {() => void}\n     */\n    observe(element2, listener) {\n      this._listeners.set(element2, listener);\n      this._getObserver().observe(element2, this.options);\n      return () => {\n        this._listeners.delete(element2);\n        this._observer.unobserve(element2);\n      };\n    }\n    /**\n     * @private\n     */\n    _getObserver() {\n      return this._observer ?? (this._observer = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          _ResizeObserverSingleton.entries.set(entry.target, entry);\n          this._listeners.get(entry.target)?.(entry);\n        }\n      }));\n    }\n  };\n  ResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n\n  // node_modules/svelte/src/runtime/internal/dom.js\n  var is_hydrating = false;\n  function start_hydrating() {\n    is_hydrating = true;\n  }\n  function end_hydrating() {\n    is_hydrating = false;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function children(element2) {\n    return Array.from(element2.childNodes);\n  }\n  function set_data(text2, data) {\n    data = \"\" + data;\n    if (text2.data === data) return;\n    text2.data = /** @type {string} */\n    data;\n  }\n  function get_custom_elements_slots(element2) {\n    const result = {};\n    element2.childNodes.forEach(\n      /** @param {Element} node */\n      (node) => {\n        result[node.slot || \"default\"] = true;\n      }\n    );\n    return result;\n  }\n\n  // node_modules/svelte/src/runtime/internal/lifecycle.js\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n\n  // node_modules/svelte/src/runtime/internal/scheduler.js\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = /* @__PURE__ */ Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  var seen_callbacks = /* @__PURE__ */ new Set();\n  var flushidx = 0;\n  function flush() {\n    if (flushidx !== 0) {\n      return;\n    }\n    const saved_component = current_component;\n    do {\n      try {\n        while (flushidx < dirty_components.length) {\n          const component = dirty_components[flushidx];\n          flushidx++;\n          set_current_component(component);\n          update(component.$$);\n        }\n      } catch (e) {\n        dirty_components.length = 0;\n        flushidx = 0;\n        throw e;\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) binding_callbacks.pop()();\n      for (let i = 0; i < render_callbacks.length; i += 1) {\n        const callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      const dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  function flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n  }\n\n  // node_modules/svelte/src/runtime/internal/transitions.js\n  var outroing = /* @__PURE__ */ new Set();\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n\n  // node_modules/svelte/src/shared/boolean_attributes.js\n  var _boolean_attributes = (\n    /** @type {const} */\n    [\n      \"allowfullscreen\",\n      \"allowpaymentrequest\",\n      \"async\",\n      \"autofocus\",\n      \"autoplay\",\n      \"checked\",\n      \"controls\",\n      \"default\",\n      \"defer\",\n      \"disabled\",\n      \"formnovalidate\",\n      \"hidden\",\n      \"inert\",\n      \"ismap\",\n      \"loop\",\n      \"multiple\",\n      \"muted\",\n      \"nomodule\",\n      \"novalidate\",\n      \"open\",\n      \"playsinline\",\n      \"readonly\",\n      \"required\",\n      \"reversed\",\n      \"selected\"\n    ]\n  );\n  var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\n\n  // node_modules/svelte/src/runtime/internal/Component.js\n  function mount_component(component, target, anchor) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n      flush_render_callbacks($$.after_update);\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching);\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n      fragment: null,\n      ctx: [],\n      // state\n      props,\n      update: noop,\n      not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {\n      const value = rest.length ? rest[0] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        start_hydrating();\n        const nodes = children(options.target);\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor);\n      end_hydrating();\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  var SvelteElement;\n  if (typeof HTMLElement === \"function\") {\n    SvelteElement = class extends HTMLElement {\n      /** The Svelte component constructor */\n      $$ctor;\n      /** Slots */\n      $$s;\n      /** The Svelte component instance */\n      $$c;\n      /** Whether or not the custom element is connected */\n      $$cn = false;\n      /** Component props data */\n      $$d = {};\n      /** `true` if currently in the process of reflecting component props back to attributes */\n      $$r = false;\n      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n      $$p_d = {};\n      /** @type {Record<string, Function[]>} Event listeners */\n      $$l = {};\n      /** @type {Map<Function, Function>} Event listener unsubscribe functions */\n      $$l_u = /* @__PURE__ */ new Map();\n      constructor($$componentCtor, $$slots, use_shadow_dom) {\n        super();\n        this.$$ctor = $$componentCtor;\n        this.$$s = $$slots;\n        if (use_shadow_dom) {\n          this.attachShadow({ mode: \"open\" });\n        }\n      }\n      addEventListener(type, listener, options) {\n        this.$$l[type] = this.$$l[type] || [];\n        this.$$l[type].push(listener);\n        if (this.$$c) {\n          const unsub = this.$$c.$on(type, listener);\n          this.$$l_u.set(listener, unsub);\n        }\n        super.addEventListener(type, listener, options);\n      }\n      removeEventListener(type, listener, options) {\n        super.removeEventListener(type, listener, options);\n        if (this.$$c) {\n          const unsub = this.$$l_u.get(listener);\n          if (unsub) {\n            unsub();\n            this.$$l_u.delete(listener);\n          }\n        }\n      }\n      async connectedCallback() {\n        this.$$cn = true;\n        if (!this.$$c) {\n          let create_slot = function(name) {\n            return () => {\n              let node;\n              const obj = {\n                c: function create() {\n                  node = element(\"slot\");\n                  if (name !== \"default\") {\n                    attr(node, \"name\", name);\n                  }\n                },\n                /**\n                 * @param {HTMLElement} target\n                 * @param {HTMLElement} [anchor]\n                 */\n                m: function mount(target, anchor) {\n                  insert(target, node, anchor);\n                },\n                d: function destroy(detaching) {\n                  if (detaching) {\n                    detach(node);\n                  }\n                }\n              };\n              return obj;\n            };\n          };\n          await Promise.resolve();\n          if (!this.$$cn || this.$$c) {\n            return;\n          }\n          const $$slots = {};\n          const existing_slots = get_custom_elements_slots(this);\n          for (const name of this.$$s) {\n            if (name in existing_slots) {\n              $$slots[name] = [create_slot(name)];\n            }\n          }\n          for (const attribute of this.attributes) {\n            const name = this.$$g_p(attribute.name);\n            if (!(name in this.$$d)) {\n              this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, \"toProp\");\n            }\n          }\n          for (const key in this.$$p_d) {\n            if (!(key in this.$$d) && this[key] !== void 0) {\n              this.$$d[key] = this[key];\n              delete this[key];\n            }\n          }\n          this.$$c = new this.$$ctor({\n            target: this.shadowRoot || this,\n            props: {\n              ...this.$$d,\n              $$slots,\n              $$scope: {\n                ctx: []\n              }\n            }\n          });\n          const reflect_attributes = () => {\n            this.$$r = true;\n            for (const key in this.$$p_d) {\n              this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n              if (this.$$p_d[key].reflect) {\n                const attribute_value = get_custom_element_value(\n                  key,\n                  this.$$d[key],\n                  this.$$p_d,\n                  \"toAttribute\"\n                );\n                if (attribute_value == null) {\n                  this.removeAttribute(this.$$p_d[key].attribute || key);\n                } else {\n                  this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n                }\n              }\n            }\n            this.$$r = false;\n          };\n          this.$$c.$$.after_update.push(reflect_attributes);\n          reflect_attributes();\n          for (const type in this.$$l) {\n            for (const listener of this.$$l[type]) {\n              const unsub = this.$$c.$on(type, listener);\n              this.$$l_u.set(listener, unsub);\n            }\n          }\n          this.$$l = {};\n        }\n      }\n      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n      // and setting attributes through setAttribute etc, this is helpful\n      attributeChangedCallback(attr2, _oldValue, newValue) {\n        if (this.$$r) return;\n        attr2 = this.$$g_p(attr2);\n        this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, \"toProp\");\n        this.$$c?.$set({ [attr2]: this.$$d[attr2] });\n      }\n      disconnectedCallback() {\n        this.$$cn = false;\n        Promise.resolve().then(() => {\n          if (!this.$$cn && this.$$c) {\n            this.$$c.$destroy();\n            this.$$c = void 0;\n          }\n        });\n      }\n      $$g_p(attribute_name) {\n        return Object.keys(this.$$p_d).find(\n          (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name\n        ) || attribute_name;\n      }\n    };\n  }\n  function get_custom_element_value(prop, value, props_definition, transform) {\n    const type = props_definition[prop]?.type;\n    value = type === \"Boolean\" && typeof value !== \"boolean\" ? value != null : value;\n    if (!transform || !props_definition[prop]) {\n      return value;\n    } else if (transform === \"toAttribute\") {\n      switch (type) {\n        case \"Object\":\n        case \"Array\":\n          return value == null ? null : JSON.stringify(value);\n        case \"Boolean\":\n          return value ? \"\" : null;\n        case \"Number\":\n          return value == null ? null : value;\n        default:\n          return value;\n      }\n    } else {\n      switch (type) {\n        case \"Object\":\n        case \"Array\":\n          return value && JSON.parse(value);\n        case \"Boolean\":\n          return value;\n        // conversion already handled above\n        case \"Number\":\n          return value != null ? +value : value;\n        default:\n          return value;\n      }\n    }\n  }\n  function create_custom_element(Component, props_definition, slots, accessors, use_shadow_dom, extend) {\n    let Class = class extends SvelteElement {\n      constructor() {\n        super(Component, slots, use_shadow_dom);\n        this.$$p_d = props_definition;\n      }\n      static get observedAttributes() {\n        return Object.keys(props_definition).map(\n          (key) => (props_definition[key].attribute || key).toLowerCase()\n        );\n      }\n    };\n    Object.keys(props_definition).forEach((prop) => {\n      Object.defineProperty(Class.prototype, prop, {\n        get() {\n          return this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n        },\n        set(value) {\n          value = get_custom_element_value(prop, value, props_definition);\n          this.$$d[prop] = value;\n          this.$$c?.$set({ [prop]: value });\n        }\n      });\n    });\n    accessors.forEach((accessor) => {\n      Object.defineProperty(Class.prototype, accessor, {\n        get() {\n          return this.$$c?.[accessor];\n        }\n      });\n    });\n    if (extend) {\n      Class = extend(Class);\n    }\n    Component.element = /** @type {any} */\n    Class;\n    return Class;\n  }\n  var SvelteComponent = class {\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    $$ = void 0;\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    $$set = void 0;\n    /** @returns {void} */\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    /**\n     * @template {Extract<keyof Events, string>} K\n     * @param {K} type\n     * @param {((e: Events[K]) => void) | null | undefined} callback\n     * @returns {() => void}\n     */\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      };\n    }\n    /**\n     * @param {Partial<Props>} props\n     * @returns {void}\n     */\n    $set(props) {\n      if (this.$$set && !is_empty(props)) {\n        this.$$.skip_bound = true;\n        this.$$set(props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n\n  // node_modules/svelte/src/shared/version.js\n  var PUBLIC_VERSION = \"4\";\n\n  // node_modules/svelte/src/runtime/internal/disclose-version/index.js\n  if (typeof window !== \"undefined\")\n    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);\n\n  // src/sources/example.svelte\n  function create_fragment(ctx) {\n    let p;\n    let t0;\n    let t1;\n    let t2;\n    return {\n      c() {\n        p = element(\"p\");\n        t0 = text(\"My favourite meal is \");\n        t1 = text(\n          /*meal*/\n          ctx[0]\n        );\n        t2 = text(\"!\");\n      },\n      m(target, anchor) {\n        insert(target, p, anchor);\n        append(p, t0);\n        append(p, t1);\n        append(p, t2);\n      },\n      p(ctx2, [dirty]) {\n        if (dirty & /*meal*/\n        1) set_data(\n          t1,\n          /*meal*/\n          ctx2[0]\n        );\n      },\n      i: noop,\n      o: noop,\n      d(detaching) {\n        if (detaching) {\n          detach(p);\n        }\n      }\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    let { meal = \"breakfast\" } = $$props;\n    $$self.$$set = ($$props2) => {\n      if (\"meal\" in $$props2) $$invalidate(0, meal = $$props2.meal);\n    };\n    return [meal];\n  }\n  var Example = class extends SvelteComponent {\n    constructor(options) {\n      super();\n      init(this, options, instance, create_fragment, safe_not_equal, { meal: 0 });\n    }\n    get meal() {\n      return this.$$.ctx[0];\n    }\n    set meal(meal) {\n      this.$$set({ meal });\n      flush();\n    }\n  };\n  customElements.define(\"example-source\", create_custom_element(Example, { \"meal\": {} }, [], [], true));\n})();\n"}